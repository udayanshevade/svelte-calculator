{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "Button.svelte",
    "Display.svelte",
    "Calculator.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import classnames from 'classnames';\nexport let text;\nexport let id;\nexport let className;\nexport let title;\nexport let value = null;\nexport let onClick;\nexport let highlighted = false;\n</script>\n\n<style>\n  .button {\n    height: 3.6rem;\n    width: 3.6rem;\n    margin: 0 0 0.5rem 0;\n    background: #333;\n    color: #fff;\n    font-weight: lighter;\n    border-radius: 0.2rem;\n    border: 1px solid #2222;\n    box-shadow: 3px 5px 8px rgba(0, 0, 0, 0.3);\n    user-select: none;\n    transition: background 0.12s ease-in-out;\n  }\n  .button:active,\n  .button.highlighted {\n    box-shadow: 1px 3px 6px rgba(0, 0, 0, 0.3);\n    background: #555;\n  }\n\n  .button:hover {\n    cursor: pointer;\n    background: #3a3a3a;\n    box-shadow: 2px 4px 5px rgba(0, 0, 0, 0.4);\n  }\n</style>\n\n<button\n  {id}\n  class={classnames('button', className, highlighted && 'highlighted')}\n  {title}\n  {value}\n  on:click={onClick}>\n  {text}\n</button>\n",
    "<script lang=\"ts\">export let displayValue = '';\nexport let warning = null;\n</script>\n\n<style>\n  .display-container {\n    border-top-left-radius: 1rem;\n    border-top-right-radius: 1rem;\n    height: 6rem;\n    max-width: 100%;\n    border-bottom: 1px solid #222;\n    display: flex;\n    align-items: flex-end;\n    justify-content: flex-end;\n    overflow-y: auto;\n  }\n\n  .display-inner {\n    padding: 0.25rem 0.5rem 0.25rem 0.25rem;\n  }\n\n  .display {\n    font-size: 1.6rem;\n    color: #fff;\n    text-align: right;\n    width: 100%;\n    word-break: break-word;\n  }\n</style>\n\n<section class=\"display-container\" role=\"region\">\n  <div class=\"display-inner\">\n    <div class=\"display\">{warning || displayValue}</div>\n  </div>\n</section>\n",
    "<script lang=\"ts\" context=\"module\">;\nconst toFixedDigits = 10;\n// reduce the array by immediate execution\n// TODO: use formula logic\nexport const computeValue = (stack) => {\n    const output = stack.reduce((acc, next, i) => {\n        const asNumber = Number(next);\n        if (isValidNumber(asNumber)) {\n            if (i === 0)\n                return asNumber;\n            const lastOperation = stack[i - 1];\n            return operationHandlers[lastOperation](acc, asNumber);\n        }\n        return acc;\n    }, 0);\n    // round to fixed number of digits\n    return Number(output.toFixed(toFixedDigits));\n};\nexport const getDisplayValue = (stack) => {\n    if (!stack.length)\n        return '0';\n    return stack\n        .map((val) => {\n        if (isNumber(val)) {\n            return Math.min(val, Number.MAX_SAFE_INTEGER);\n        }\n        return val;\n    })\n        .join(' ');\n};\n</script>\n\n<script lang=\"ts\">import classnames from 'classnames';\nimport Display from '../../components/Display/Display.svelte';\nimport Button from '../../components/Button/Button.svelte';\nimport { config } from './config';\nimport { isNumber, isDigit, isValidNumber, isString, isOperator, suffix, mergeNumbers, suffixDecimal, operationHandlers, } from './helpers';\nlet stack = [];\n$: displayValue = getDisplayValue(stack);\nlet activeKey = null;\nlet warning = null;\nlet highlightedTimeoutId = null;\nconst highlightedTimeout = 125;\n$: {\n    if (activeKey !== null) {\n        highlightedTimeoutId = setTimeout(() => {\n            activeKey = null;\n        }, highlightedTimeout);\n    }\n    else {\n        clearTimeout(highlightedTimeoutId);\n    }\n}\nlet warningTimeoutId = null;\nconst warningTimeout = 1500;\n$: {\n    if (warning !== null) {\n        warningTimeoutId = setTimeout(() => {\n            warning = null;\n        }, warningTimeout);\n    }\n    else {\n        clearTimeout(warningTimeoutId);\n    }\n}\nconst handleDigitOperation = (newOperation) => {\n    const lastOperation = stack[stack.length - 1];\n    const secondLastOperation = stack[stack.length - 2];\n    const lastOperationIsANumber = isValidNumber(Number(lastOperation));\n    const lastOperationIsAnOperator = isOperator(lastOperation);\n    const lastOperationIsAString = isString(lastOperation);\n    const secondLastOperationIsAnOperator = isOperator(secondLastOperation);\n    const hasComputedResult = secondLastOperation === '=';\n    if (hasComputedResult) {\n        // start a new stack with a new number\n        // e.g. [12, '/', 4, '=', 3] --> [5]\n        stack = [newOperation];\n        return;\n    }\n    if (lastOperationIsANumber) {\n        // track temporary string decimal representations,\n        // which are useful for maintaining a trailing '.'\n        if (lastOperationIsAString) {\n            // if the new operation is 0, do not coerce the full value to a number yet.\n            // it still needs to be a string, or it will be pared down prematurely\n            let valueToAppend;\n            // e.g. ['123.'] --> ['123.0']\n            valueToAppend = suffix(lastOperation, newOperation);\n            if (newOperation > 0) {\n                // a non-zero value can be coerced to a number\n                // e.g. ['123.'] --> [123.4]\n                valueToAppend = Number(valueToAppend);\n            }\n            stack[stack.length - 1] = valueToAppend;\n            return;\n        }\n        // prevent consecutive 0 digits unless position is valid\n        // e.g. [0] --> [0] (no change)\n        if (lastOperation === 0 && newOperation === 0)\n            return;\n        // just merge consecutive numerical values otherwise\n        // e.g. [20] --> [200]\n        const newNum = mergeNumbers(lastOperation, Number(newOperation));\n        // ^ TODO: figure out why TS is complaining about newOperation despite type guard inside `isDigit`\n        const safeNum = Math.min(newNum, Number.MAX_SAFE_INTEGER);\n        stack[stack.length - 1] = safeNum;\n        if (safeNum === Number.MAX_SAFE_INTEGER) {\n            warning = 'Digit limit reached';\n        }\n        return;\n    }\n    if (lastOperationIsAnOperator) {\n        if (lastOperation === '-' && secondLastOperationIsAnOperator) {\n            // accommmodate '-' after another operator (for negative numbers)\n            // e.g. [12345, '/', '-'] --> [12345, '/', -3]\n            stack[stack.length - 1] = Number(suffix(lastOperation, newOperation));\n        }\n        else {\n            // else just add the new number to the stack\n            // e.g. [12345, '/'] --> [12345, '/', 3]\n            stack = [...stack, newOperation];\n        }\n        return;\n    }\n};\nconst handleDecimalOperation = (newOperation) => {\n    const lastOperation = stack[stack.length - 1];\n    const lastOperationIsANumber = isValidNumber(Number(lastOperation));\n    const lastOperationIsAnOperator = isOperator(lastOperation);\n    if (lastOperationIsANumber) {\n        // ignore if the last number is already a decimal\n        // e.g. [12.34] --> [12.34] (no change)\n        if (Math.round(Number(lastOperation)) !== lastOperation)\n            return;\n        // EDGE CASE: value being converted to decimal is -0,\n        // which otherwise gets coerced to '0'\n        if (Object.is(lastOperation, -0)) {\n            // so this retains the negative value\n            // e.g. [-0] --> ['-0.']\n            stack[stack.length - 1] = suffix('-0', newOperation);\n        }\n        else {\n            // else we just string concatenate the decimal and the number\n            // e.g. [123] --> ['123.']\n            stack[stack.length - 1] = suffixDecimal(lastOperation, newOperation);\n        }\n        return;\n    }\n    if (lastOperationIsAnOperator) {\n        // e.g. [12, '/'] --> [12, '/', '0.']\n        stack = [...stack, suffixDecimal(0, newOperation)];\n        return;\n    }\n};\nconst handleOperatorOperation = (newOperation) => {\n    const lastOperation = stack[stack.length - 1];\n    const secondLastOperation = stack[stack.length - 2];\n    const lastOperationIsANumber = isValidNumber(Number(lastOperation));\n    const lastOperationIsAnOperator = isOperator(lastOperation);\n    const secondLastOperationIsAnOperator = isOperator(secondLastOperation);\n    const hasComputedResult = secondLastOperation === '=';\n    const newOperationIsSubtract = newOperation === '-';\n    const lastOperationIsSubtract = lastOperation === '-';\n    const lastOperationIsAdd = lastOperation === '+';\n    if (hasComputedResult) {\n        // start new stack with the result\n        // e.g. [3, '*', 4, '=', 12] --> [12, '+']\n        stack = [lastOperation, newOperation];\n        return;\n    }\n    if (lastOperationIsANumber) {\n        stack = [...stack, newOperation];\n        return;\n    }\n    if (lastOperationIsAnOperator) {\n        if (newOperationIsSubtract && lastOperationIsSubtract) {\n            // convert two consecutive '-' operators to '+'\n            // e.g. [1, '-'] --> [1, '+']\n            stack[stack.length - 1] = '+';\n        }\n        else if (newOperationIsSubtract && lastOperationIsAdd) {\n            // e.g. [1, '+'] --> [1, '-']\n            stack[stack.length - 1] = '-';\n        }\n        else if (newOperationIsSubtract) {\n            // e.g. [1] --> [1, '-']\n            stack = [...stack, newOperation];\n        }\n        else if (lastOperationIsSubtract && secondLastOperationIsAnOperator) {\n            // if lastOperation is '-' and is preceded by another operator\n            // overwrite both with the new operator\n            // e.g. [123, '/', '-'] --> [123, '*']\n            stack = [...stack.slice(0, stack.length - 2), newOperation];\n        }\n        else {\n            // else just overwrite the last operator\n            // e.g. [123, '/'] --> [123, '*']\n            stack[stack.length - 1] = newOperation;\n        }\n    }\n};\nconst handleEqualsOperation = (newOperation) => {\n    const lastOperation = stack[stack.length - 1];\n    const secondLastOperation = stack[stack.length - 2];\n    const lastOperationIsAnOperator = isOperator(lastOperation);\n    const lastOperationIsANumber = isValidNumber(Number(lastOperation));\n    const hasComputedResult = secondLastOperation === '=';\n    // ignore duplicate operation\n    // e.g. [1, '+', 1, '=', 2] --> [1, '+', 1, '=', 2] (no change)\n    if (hasComputedResult)\n        return;\n    if (lastOperationIsAnOperator) {\n        // replace the previous operator, then compute\n        // e.g. [1, '+', 1, '/'] --> [1, '+', 1, '=', 2]\n        const result = computeValue(stack);\n        stack = [...stack.slice(0, stack.length - 1), newOperation, result];\n        return;\n    }\n    if (lastOperationIsANumber) {\n        // otherwise just compute the result\n        // e.g. [1, '+', 1, '=', 2] --> [1, '+', 1, '=', 2]\n        const result = computeValue(stack);\n        stack = [...stack, newOperation, result];\n    }\n};\nconst handleButtonClick = (newOperation) => {\n    if (newOperation === 'clear') {\n        stack = [];\n        return;\n    }\n    if (!stack.length) {\n        if (isDigit(newOperation)) {\n            stack = [newOperation];\n        }\n        else if (isOperator(newOperation) || newOperation === '.') {\n            handleButtonClick(0);\n            handleButtonClick(newOperation);\n        }\n        return;\n    }\n    if (newOperation === '=') {\n        handleEqualsOperation(newOperation);\n        return;\n    }\n    if (isDigit(newOperation)) {\n        handleDigitOperation(newOperation);\n        return;\n    }\n    if (newOperation === '.') {\n        handleDecimalOperation(newOperation);\n        return;\n    }\n    if (isOperator(newOperation)) {\n        handleOperatorOperation(newOperation);\n        return;\n    }\n};\nconst handleKeydown = (e) => {\n    let valueToHandle = null;\n    if (isDigit(e.key)) {\n        valueToHandle = Number(e.key);\n    }\n    else if (/[\\/\\*\\-\\+\\=]/.test(e.key)) {\n        valueToHandle = e.key;\n    }\n    else if (e.key === 'Enter') {\n        valueToHandle = '=';\n    }\n    else if (e.key === 'Escape') {\n        valueToHandle = 'clear';\n    }\n    else if (e.key === '.') {\n        valueToHandle = '.';\n    }\n    if (valueToHandle !== null) {\n        activeKey = valueToHandle;\n        handleButtonClick(valueToHandle);\n    }\n};\n</script>\n\n<style>\n  .calculator {\n    border-radius: 1rem;\n    border: 2px solid #222;\n    background: #333;\n    max-width: 100%;\n    width: 15rem;\n    padding: 0.5rem;\n    margin: 0 auto;\n  }\n  .calculator-inner {\n    border-radius: 1rem;\n    border: 1px solid #222;\n    width: 100%;\n  }\n  .row {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, calc(25% - 0.075rem));\n    grid-column-gap: 0.1rem;\n  }\n  .row--full {\n    grid-template-columns: auto;\n  }\n  .calculator .row--full :global(.button) {\n    margin: 0.25rem 0 0.5rem;\n    width: auto;\n  }\n  .calculator .row:last-of-type :global(.button) {\n    margin-bottom: 0.25rem;\n  }\n  .calculator .row:last-of-type :global(.button:first-of-type) {\n    border-bottom-left-radius: 0.5rem;\n  }\n  .calculator .row:last-of-type :global(.button:last-of-type) {\n    border-bottom-right-radius: 0.5rem;\n  }\n</style>\n\n<svelte:window on:keydown={handleKeydown} />\n\n<div class=\"calculator\">\n  <div class=\"calculator-inner\">\n    <Display {displayValue} {warning} />\n    {#each config as { className: rowClassName, config: rowConfig }}\n      <div class={classnames('row', rowClassName)}>\n        {#each rowConfig as { id, value, title, className, text } (id)}\n          <Button\n            {id}\n            {title}\n            className={classnames(className)}\n            {text}\n            {value}\n            onClick={() => handleButtonClick(value)}\n            highlighted={activeKey === value} />\n        {/each}\n      </div>\n    {/each}\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}